package main

import (
	"fmt"
	"sophie"
	"os"
	"strings"
	//"unicode"
	"strconv"
	// "github.com/aws/aws-sdk-go/service/s3"
	// "github.com/aws/aws-sdk-go/aws"
	// "github.com/aws/aws-sdk-go/aws/session"
	//"github.com/aws/aws-sdk-go/service/s3/s3manager"
	//"log"
	//"panel"
	"math"
	"time"
)
func findPrimeNumbers(limit int) int {
	if limit <= 1 {
		return 0
	}

	// Get the sqrt of the limit
	sqrtLimit := int(math.Sqrt(float64(limit)))

	// Create array
	numbers := make([]bool, limit)

	// Set 1 to prime
	numbers[0] = true
	numPrimes := 0

	// Count the number of olds
	if limit%2 == 0 {
		numPrimes = limit / 2
	} else {
		numPrimes = (limit + 1) / 2
	}

	start_time := time.Now()
	// Loop through odd numbers
	for i := 3; i <= sqrtLimit; i += 2 {
		if !numbers[i] {
			for j := i*i; j < limit; j += i*2 {
				if !numbers[j] {
					numbers[j] = true
					numPrimes -= 1
				}
			}
		}
	}

	elapsed_time := time.Since(start_time).Seconds()
	fmt.Println(elapsed_time)

	return numPrimes
}
//func findPrimeNumbers(N int) (numberOfPrimes int) {
//	var x, y, n int
//	nsqrt := math.Sqrt(float64(N))
//
//	//is_prime := [N]bool{}
//	is_prime := make([]bool, N)
//
//	start_time := time.Now()
//	for x = 1; float64(x) <= nsqrt; x++ {
//		for y = 1; float64(y) <= nsqrt; y++ {
//			n = 4*(x*x) + y*y
//			if n <= N && (n%12 == 1 || n%12 == 5) {
//				is_prime[n] = !is_prime[n]
//			}
//			n = 3*(x*x) + y*y
//			if n <= N && n%12 == 7 {
//				is_prime[n] = !is_prime[n]
//			}
//			n = 3*(x*x) - y*y
//			if x > y && n <= N && n%12 == 11 {
//				is_prime[n] = !is_prime[n]
//			}
//		}
//	}
//
//	for n = 5; float64(n) <= nsqrt; n++ {
//		if is_prime[n] {
//			for y = n * n; y < N; y += n * n {
//				is_prime[y] = false
//			}
//		}
//	}
//
//	elapsed_time := time.Since(start_time).Seconds()
//
//	fmt.Println(elapsed_time)
//	is_prime[2] = true
//	is_prime[3] = true
//
//	//primes := make([]int, 0, N)
//	//primes := make([]int, 0, 1270606)
//
//	for x = 0; x < len(is_prime)-1; x++ {
//		if is_prime[x] {
//			//primes = append(primes, x)
//			numberOfPrimes++
//		}
//	}
//	//numberOfPrimes = len(primes)
//
//	return
//	// primes is now a slice that contains all the
//	// primes numbers up to N
//
//	// let's print them
//	//for _, x := range primes {
//	//	fmt.Println(x)
//	//}
//}

// The mapping function is called once for each piece of the input.
// In this framework, the key is the name of the file that is being processed,
// and the value is the file's contents. The return value should be a slice of
// key/value pairs, each represented by a sophie.KeyValue.
func mapF(document string, value string) (res []sophie.KeyValue) {
	random_numbers := strings.Split(value, "\n")

	for _, w := range random_numbers {
		number, err := strconv.Atoi(w)
		if err == nil {
			numberOfPrimes := findPrimeNumbers(number)
			kv := sophie.KeyValue {strconv.Itoa(numberOfPrimes), w}
			res = append(res, kv)
		}
	}

	return
}

// The reduce function is called once for each key generated by Map, with a
// list of that key's string value (merged across all inputs). The return value
// should be a single output value for that key.
func reduceF(key string, values []string) string {
	// TODO: you also have to write this function
	return strconv.Itoa(len(values))
}

// Can be run in 3 ways:
// 1) Sequential (e.g., go run wc.go master sequential x1.txt .. xN.txt)
// 2) Master (e.g., go run wc.go master localhost:7777 x1.txt .. xN.txt 1 1)
// 3) Worker (e.g., go run wc.go worker localhost:7777 localhost:7778 &)

// amazon s3
// 1) master: go run src/main/primality_mr.go master localhost:7777 random 1 1
// 2) worker: go run src/main/primality_mr.go worker localhost:7777 localhost:7778
func main() {
	if (len(os.Args) == 4 && os.Args[1] == "worker") {
		sophie.RunWorker(os.Args[2], os.Args[3], mapF, reduceF, 100000)
	} else if (len(os.Args) == 6 && os.Args[1] == "master") {
		//var mr *sophie.Master
		fmt.Println(os.Args[2])
		if os.Args[2] == "sequential" {
			//mr = sophie.Sequential("wcseq", sophie.GetKeys(os.Args[3]), 3, mapF, reduceF) // os.Args[3:]
			sophie.Sequential("wcseq", sophie.GetKeys(os.Args[3]), 3, mapF, reduceF) // os.Args[3:]

		} else {
			//mr = sophie.Distributed("wc_distributed", sophie.GetKeys(os.Args[3]), 3, os.Args[2]) // os.Args[3:]
			//sophie.Distributed("wc_distributed", sophie.GetKeys(os.Args[3]), 3, os.Args[2]) // os.Args[3:]

			//change the number of reducers to 16 to accommodate ecs docker benchmark
			nreduce, err := strconv.Atoi(os.Args[4])
			if err != nil {
				fmt.Println("nreduce is wrong")
				return
			}
			nworkers, err1 := strconv.Atoi(os.Args[5])
			if err1 != nil {
				fmt.Println("nworkers is wrong")
				return
			}
			sophie.Distributed("wc_distributed", sophie.GetKeys(os.Args[3]), nreduce, os.Args[2], nworkers) // os.Args[3:]
			//sophie.Distributed("wc_distributed", os.Args[3], nreduce, os.Args[2], nworkers) // os.Args[3:]

		}
		//panel.StartServer(mr)
		//mr.Wait()
	} else {
		fmt.Printf("%s: see usage comments in file\n", os.Args[0])
	}
}
