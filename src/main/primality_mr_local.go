package main

import (
	"fmt"
	"mapreduce"
	"os"
	"strings"
	//"unicode"
	"strconv"
	// "github.com/aws/aws-sdk-go/service/s3"
	// "github.com/aws/aws-sdk-go/aws"
	// "github.com/aws/aws-sdk-go/aws/session"
	//"github.com/aws/aws-sdk-go/service/s3/s3manager"
	//"log"
	//"panel"
	//"math"
	//"time"
	"sophie"
	"math"
)
func findPrimeNumbers(n int) int {
	if (n <= 2) {
		return 0
	}

	// init an array to track prime numbers
	primes := make([]bool, n)
	for i := 2; i < n; i++ {
		primes[i] = true
	}


	for i := 2; float64(i) <= math.Sqrt(float64(n - 1)); i++ {
		if (primes[i]) {
			for j := i + i; j < n; j += i {
				primes[j] = false
			}
		}
	}

	count := 0
	for i := 2; i < n; i++ {
		if (primes[i]) {
			count++
		}
	}

	return count
}
//func findPrimeNumbers(N int) (numberOfPrimes int) {
//	var x, y, n int
//	nsqrt := math.Sqrt(float64(N))
//
//	//is_prime := [N]bool{}
//	is_prime := make([]bool, N)
//
//	start_time := time.Now()
//	for x = 1; float64(x) <= nsqrt; x++ {
//		for y = 1; float64(y) <= nsqrt; y++ {
//			n = 4*(x*x) + y*y
//			if n <= N && (n%12 == 1 || n%12 == 5) {
//				is_prime[n] = !is_prime[n]
//			}
//			n = 3*(x*x) + y*y
//			if n <= N && n%12 == 7 {
//				is_prime[n] = !is_prime[n]
//			}
//			n = 3*(x*x) - y*y
//			if x > y && n <= N && n%12 == 11 {
//				is_prime[n] = !is_prime[n]
//			}
//		}
//	}
//
//	for n = 5; float64(n) <= nsqrt; n++ {
//		if is_prime[n] {
//			for y = n * n; y < N; y += n * n {
//				is_prime[y] = false
//			}
//		}
//	}
//
//	elapsed_time := time.Since(start_time).Seconds()
//
//	fmt.Println(elapsed_time)
//	is_prime[2] = true
//	is_prime[3] = true
//
//	//primes := make([]int, 0, N)
//	//primes := make([]int, 0, 1270606)
//
//	for x = 0; x < len(is_prime)-1; x++ {
//		if is_prime[x] {
//			//primes = append(primes, x)
//			numberOfPrimes++
//		}
//	}
//	//numberOfPrimes = len(primes)
//
//	return
//	// primes is now a slice that contains all the
//	// primes numbers up to N
//
//	// let's print them
//	//for _, x := range primes {
//	//	fmt.Println(x)
//	//}
//}

// The mapping function is called once for each piece of the input.
// In this framework, the key is the name of the file that is being processed,
// and the value is the file's contents. The return value should be a slice of
// key/value pairs, each represented by a sophie.KeyValue.
func mapF(document string, value string) (res []mapreduce.KeyValue) {
	random_numbers := strings.Split(value, "\n")

	for _, w := range random_numbers {
		number, err := strconv.Atoi(w)
		if err == nil {
			numberOfPrimes := findPrimeNumbers(number)
			kv := mapreduce.KeyValue {strconv.Itoa(numberOfPrimes), w}
			res = append(res, kv)
		}
	}

	return
}

// The reduce function is called once for each key generated by Map, with a
// list of that key's string value (merged across all inputs). The return value
// should be a single output value for that key.
func reduceF(key string, values []string) string {
	// TODO: you also have to write this function
	return strconv.Itoa(len(values))
}

// Can be run in 3 ways:
// 1) Sequential (e.g., go run wc.go master sequential x1.txt .. xN.txt)
// 2) Master (e.g., go run wc.go master localhost:7777 x1.txt .. xN.txt 1 1)
// 3) Worker (e.g., go run wc.go worker localhost:7777 localhost:7778 &)

// amazon s3
// 1) master: go run src/main/primality_mr.go master localhost:7777 random 1 1
// 2) worker: go run src/main/primality_mr.go worker localhost:7777 localhost:7778
func main() {
	if (len(os.Args) == 4 && os.Args[1] == "worker") {
		mapreduce.RunWorker(os.Args[2], os.Args[3], mapF, reduceF, 100000)
	} else if os.Args[1] == "master" {
		//var mr *sophie.Master
		fmt.Println(os.Args[2])
		var mr *mapreduce.Master
		if os.Args[2] == "sequential" {
			//mr = sophie.Sequential("wcseq", sophie.GetKeys(os.Args[3]), 3, mapF, reduceF) // os.Args[3:]
			mr = mapreduce.Sequential("wcseq", sophie.GetKeys(os.Args[3]), 3, mapF, reduceF) // os.Args[3:]

		} else {
			mr = mapreduce.Distributed("wc_distributed", os.Args[3:], 3, os.Args[2]) // os.Args[3:]

		}
		//panel.StartServer(mr)
		mr.Wait()
	} else {
		fmt.Printf("%s: see usage comments in file\n", os.Args[0])
	}
}

